// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: openim.proto

package conf

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OpenIM configuration
type OpenIM struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server configuration
	Server *Server `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Client configuration
	Client *Client `protobuf:"bytes,2,opt,name=client,proto3" json:"client,omitempty"`
	// Message configuration
	Message *Message `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Security configuration
	Security *Security `protobuf:"bytes,4,opt,name=security,proto3" json:"security,omitempty"`
	// Storage configuration
	Storage       *Storage `protobuf:"bytes,5,opt,name=storage,proto3" json:"storage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenIM) Reset() {
	*x = OpenIM{}
	mi := &file_openim_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenIM) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenIM) ProtoMessage() {}

func (x *OpenIM) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenIM.ProtoReflect.Descriptor instead.
func (*OpenIM) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{0}
}

func (x *OpenIM) GetServer() *Server {
	if x != nil {
		return x.Server
	}
	return nil
}

func (x *OpenIM) GetClient() *Client {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *OpenIM) GetMessage() *Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *OpenIM) GetSecurity() *Security {
	if x != nil {
		return x.Security
	}
	return nil
}

func (x *OpenIM) GetStorage() *Storage {
	if x != nil {
		return x.Storage
	}
	return nil
}

// Server configuration
type Server struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server address (e.g., "localhost:10002")
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// API version
	ApiVersion string `protobuf:"bytes,2,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// Platform ID
	PlatformId int32 `protobuf:"varint,3,opt,name=platform_id,json=platformId,proto3" json:"platform_id,omitempty"`
	// Server name
	ServerName string `protobuf:"bytes,4,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Log level
	LogLevel string `protobuf:"bytes,5,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
	// Log output path
	LogOutputPath string `protobuf:"bytes,6,opt,name=log_output_path,json=logOutputPath,proto3" json:"log_output_path,omitempty"`
	// Log rotation max size (MB)
	LogRotationMaxSize int32 `protobuf:"varint,7,opt,name=log_rotation_max_size,json=logRotationMaxSize,proto3" json:"log_rotation_max_size,omitempty"`
	// Log rotation max age (days)
	LogRotationMaxAge int32 `protobuf:"varint,8,opt,name=log_rotation_max_age,json=logRotationMaxAge,proto3" json:"log_rotation_max_age,omitempty"`
	// Log rotation max backups
	LogRotationMaxBackups int32 `protobuf:"varint,9,opt,name=log_rotation_max_backups,json=logRotationMaxBackups,proto3" json:"log_rotation_max_backups,omitempty"`
	// Log is stdout
	LogIsStdout bool `protobuf:"varint,10,opt,name=log_is_stdout,json=logIsStdout,proto3" json:"log_is_stdout,omitempty"`
	// Log is json
	LogIsJson bool `protobuf:"varint,11,opt,name=log_is_json,json=logIsJson,proto3" json:"log_is_json,omitempty"`
	// Log with stack
	LogWithStack  bool `protobuf:"varint,12,opt,name=log_with_stack,json=logWithStack,proto3" json:"log_with_stack,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Server) Reset() {
	*x = Server{}
	mi := &file_openim_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Server) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Server) ProtoMessage() {}

func (x *Server) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{1}
}

func (x *Server) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *Server) GetApiVersion() string {
	if x != nil {
		return x.ApiVersion
	}
	return ""
}

func (x *Server) GetPlatformId() int32 {
	if x != nil {
		return x.PlatformId
	}
	return 0
}

func (x *Server) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *Server) GetLogLevel() string {
	if x != nil {
		return x.LogLevel
	}
	return ""
}

func (x *Server) GetLogOutputPath() string {
	if x != nil {
		return x.LogOutputPath
	}
	return ""
}

func (x *Server) GetLogRotationMaxSize() int32 {
	if x != nil {
		return x.LogRotationMaxSize
	}
	return 0
}

func (x *Server) GetLogRotationMaxAge() int32 {
	if x != nil {
		return x.LogRotationMaxAge
	}
	return 0
}

func (x *Server) GetLogRotationMaxBackups() int32 {
	if x != nil {
		return x.LogRotationMaxBackups
	}
	return 0
}

func (x *Server) GetLogIsStdout() bool {
	if x != nil {
		return x.LogIsStdout
	}
	return false
}

func (x *Server) GetLogIsJson() bool {
	if x != nil {
		return x.LogIsJson
	}
	return false
}

func (x *Server) GetLogWithStack() bool {
	if x != nil {
		return x.LogWithStack
	}
	return false
}

// Client configuration
type Client struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client user ID
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Client token
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// Client platform ID
	PlatformId int32 `protobuf:"varint,3,opt,name=platform_id,json=platformId,proto3" json:"platform_id,omitempty"`
	// Client server address
	ServerAddr string `protobuf:"bytes,4,opt,name=server_addr,json=serverAddr,proto3" json:"server_addr,omitempty"`
	// Client API version
	ApiVersion string `protobuf:"bytes,5,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// Client timeout
	Timeout *durationpb.Duration `protobuf:"bytes,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Client heartbeat interval
	HeartbeatInterval *durationpb.Duration `protobuf:"bytes,7,opt,name=heartbeat_interval,json=heartbeatInterval,proto3" json:"heartbeat_interval,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Client) Reset() {
	*x = Client{}
	mi := &file_openim_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Client) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Client) ProtoMessage() {}

func (x *Client) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Client.ProtoReflect.Descriptor instead.
func (*Client) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{2}
}

func (x *Client) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *Client) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *Client) GetPlatformId() int32 {
	if x != nil {
		return x.PlatformId
	}
	return 0
}

func (x *Client) GetServerAddr() string {
	if x != nil {
		return x.ServerAddr
	}
	return ""
}

func (x *Client) GetApiVersion() string {
	if x != nil {
		return x.ApiVersion
	}
	return ""
}

func (x *Client) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *Client) GetHeartbeatInterval() *durationpb.Duration {
	if x != nil {
		return x.HeartbeatInterval
	}
	return nil
}

// Message configuration
type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Message type (text, image, voice, video, file, etc.)
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Message content
	Content string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	// Message sender
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// Message receiver
	Receiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
	// Message group ID (for group messages)
	GroupId string `protobuf:"bytes,5,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// Message sequence number
	Sequence int64 `protobuf:"varint,6,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Message timestamp
	Timestamp int64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Message status
	Status        string `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_openim_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{3}
}

func (x *Message) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Message) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *Message) GetSender() string {
	if x != nil {
		return x.Sender
	}
	return ""
}

func (x *Message) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *Message) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *Message) GetSequence() int64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *Message) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Message) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

// Security configuration
type Security struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable TLS
	TlsEnable bool `protobuf:"varint,1,opt,name=tls_enable,json=tlsEnable,proto3" json:"tls_enable,omitempty"`
	// TLS certificate file
	TlsCertFile string `protobuf:"bytes,2,opt,name=tls_cert_file,json=tlsCertFile,proto3" json:"tls_cert_file,omitempty"`
	// TLS key file
	TlsKeyFile string `protobuf:"bytes,3,opt,name=tls_key_file,json=tlsKeyFile,proto3" json:"tls_key_file,omitempty"`
	// TLS CA file
	TlsCaFile string `protobuf:"bytes,4,opt,name=tls_ca_file,json=tlsCaFile,proto3" json:"tls_ca_file,omitempty"`
	// Enable authentication
	AuthEnable bool `protobuf:"varint,5,opt,name=auth_enable,json=authEnable,proto3" json:"auth_enable,omitempty"`
	// JWT secret
	JwtSecret string `protobuf:"bytes,6,opt,name=jwt_secret,json=jwtSecret,proto3" json:"jwt_secret,omitempty"`
	// JWT expire time
	JwtExpire     *durationpb.Duration `protobuf:"bytes,7,opt,name=jwt_expire,json=jwtExpire,proto3" json:"jwt_expire,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Security) Reset() {
	*x = Security{}
	mi := &file_openim_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Security) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Security) ProtoMessage() {}

func (x *Security) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Security.ProtoReflect.Descriptor instead.
func (*Security) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{4}
}

func (x *Security) GetTlsEnable() bool {
	if x != nil {
		return x.TlsEnable
	}
	return false
}

func (x *Security) GetTlsCertFile() string {
	if x != nil {
		return x.TlsCertFile
	}
	return ""
}

func (x *Security) GetTlsKeyFile() string {
	if x != nil {
		return x.TlsKeyFile
	}
	return ""
}

func (x *Security) GetTlsCaFile() string {
	if x != nil {
		return x.TlsCaFile
	}
	return ""
}

func (x *Security) GetAuthEnable() bool {
	if x != nil {
		return x.AuthEnable
	}
	return false
}

func (x *Security) GetJwtSecret() string {
	if x != nil {
		return x.JwtSecret
	}
	return ""
}

func (x *Security) GetJwtExpire() *durationpb.Duration {
	if x != nil {
		return x.JwtExpire
	}
	return nil
}

// Storage configuration
type Storage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Storage type (redis, mysql, mongodb, etc.)
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Storage address
	Addr string `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	// Storage username
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// Storage password
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// Storage database
	Database string `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	// Storage pool size
	PoolSize int32 `protobuf:"varint,6,opt,name=pool_size,json=poolSize,proto3" json:"pool_size,omitempty"`
	// Storage timeout
	Timeout       *durationpb.Duration `protobuf:"bytes,7,opt,name=timeout,proto3" json:"timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Storage) Reset() {
	*x = Storage{}
	mi := &file_openim_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Storage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Storage) ProtoMessage() {}

func (x *Storage) ProtoReflect() protoreflect.Message {
	mi := &file_openim_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Storage.ProtoReflect.Descriptor instead.
func (*Storage) Descriptor() ([]byte, []int) {
	return file_openim_proto_rawDescGZIP(), []int{5}
}

func (x *Storage) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Storage) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *Storage) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *Storage) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *Storage) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *Storage) GetPoolSize() int32 {
	if x != nil {
		return x.PoolSize
	}
	return 0
}

func (x *Storage) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

var File_openim_proto protoreflect.FileDescriptor

const file_openim_proto_rawDesc = "" +
	"\n" +
	"\fopenim.proto\x12\vopenim.conf\x1a\x1egoogle/protobuf/duration.proto\"\xf5\x01\n" +
	"\x06OpenIM\x12+\n" +
	"\x06server\x18\x01 \x01(\v2\x13.openim.conf.ServerR\x06server\x12+\n" +
	"\x06client\x18\x02 \x01(\v2\x13.openim.conf.ClientR\x06client\x12.\n" +
	"\amessage\x18\x03 \x01(\v2\x14.openim.conf.MessageR\amessage\x121\n" +
	"\bsecurity\x18\x04 \x01(\v2\x15.openim.conf.SecurityR\bsecurity\x12.\n" +
	"\astorage\x18\x05 \x01(\v2\x14.openim.conf.StorageR\astorage\"\xcb\x03\n" +
	"\x06Server\x12\x12\n" +
	"\x04addr\x18\x01 \x01(\tR\x04addr\x12\x1f\n" +
	"\vapi_version\x18\x02 \x01(\tR\n" +
	"apiVersion\x12\x1f\n" +
	"\vplatform_id\x18\x03 \x01(\x05R\n" +
	"platformId\x12\x1f\n" +
	"\vserver_name\x18\x04 \x01(\tR\n" +
	"serverName\x12\x1b\n" +
	"\tlog_level\x18\x05 \x01(\tR\blogLevel\x12&\n" +
	"\x0flog_output_path\x18\x06 \x01(\tR\rlogOutputPath\x121\n" +
	"\x15log_rotation_max_size\x18\a \x01(\x05R\x12logRotationMaxSize\x12/\n" +
	"\x14log_rotation_max_age\x18\b \x01(\x05R\x11logRotationMaxAge\x127\n" +
	"\x18log_rotation_max_backups\x18\t \x01(\x05R\x15logRotationMaxBackups\x12\"\n" +
	"\rlog_is_stdout\x18\n" +
	" \x01(\bR\vlogIsStdout\x12\x1e\n" +
	"\vlog_is_json\x18\v \x01(\bR\tlogIsJson\x12$\n" +
	"\x0elog_with_stack\x18\f \x01(\bR\flogWithStack\"\x99\x02\n" +
	"\x06Client\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x14\n" +
	"\x05token\x18\x02 \x01(\tR\x05token\x12\x1f\n" +
	"\vplatform_id\x18\x03 \x01(\x05R\n" +
	"platformId\x12\x1f\n" +
	"\vserver_addr\x18\x04 \x01(\tR\n" +
	"serverAddr\x12\x1f\n" +
	"\vapi_version\x18\x05 \x01(\tR\n" +
	"apiVersion\x123\n" +
	"\atimeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12H\n" +
	"\x12heartbeat_interval\x18\a \x01(\v2\x19.google.protobuf.DurationR\x11heartbeatInterval\"\xd8\x01\n" +
	"\aMessage\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x18\n" +
	"\acontent\x18\x02 \x01(\tR\acontent\x12\x16\n" +
	"\x06sender\x18\x03 \x01(\tR\x06sender\x12\x1a\n" +
	"\breceiver\x18\x04 \x01(\tR\breceiver\x12\x19\n" +
	"\bgroup_id\x18\x05 \x01(\tR\agroupId\x12\x1a\n" +
	"\bsequence\x18\x06 \x01(\x03R\bsequence\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\x03R\ttimestamp\x12\x16\n" +
	"\x06status\x18\b \x01(\tR\x06status\"\x89\x02\n" +
	"\bSecurity\x12\x1d\n" +
	"\n" +
	"tls_enable\x18\x01 \x01(\bR\ttlsEnable\x12\"\n" +
	"\rtls_cert_file\x18\x02 \x01(\tR\vtlsCertFile\x12 \n" +
	"\ftls_key_file\x18\x03 \x01(\tR\n" +
	"tlsKeyFile\x12\x1e\n" +
	"\vtls_ca_file\x18\x04 \x01(\tR\ttlsCaFile\x12\x1f\n" +
	"\vauth_enable\x18\x05 \x01(\bR\n" +
	"authEnable\x12\x1d\n" +
	"\n" +
	"jwt_secret\x18\x06 \x01(\tR\tjwtSecret\x128\n" +
	"\n" +
	"jwt_expire\x18\a \x01(\v2\x19.google.protobuf.DurationR\tjwtExpire\"\xd7\x01\n" +
	"\aStorage\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x12\n" +
	"\x04addr\x18\x02 \x01(\tR\x04addr\x12\x1a\n" +
	"\busername\x18\x03 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x04 \x01(\tR\bpassword\x12\x1a\n" +
	"\bdatabase\x18\x05 \x01(\tR\bdatabase\x12\x1b\n" +
	"\tpool_size\x18\x06 \x01(\x05R\bpoolSize\x123\n" +
	"\atimeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\atimeoutB:Z8github.com/go-lynx/lynx/plugins/service/openim/conf;confb\x06proto3"

var (
	file_openim_proto_rawDescOnce sync.Once
	file_openim_proto_rawDescData []byte
)

func file_openim_proto_rawDescGZIP() []byte {
	file_openim_proto_rawDescOnce.Do(func() {
		file_openim_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_openim_proto_rawDesc), len(file_openim_proto_rawDesc)))
	})
	return file_openim_proto_rawDescData
}

var file_openim_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_openim_proto_goTypes = []any{
	(*OpenIM)(nil),              // 0: openim.conf.OpenIM
	(*Server)(nil),              // 1: openim.conf.Server
	(*Client)(nil),              // 2: openim.conf.Client
	(*Message)(nil),             // 3: openim.conf.Message
	(*Security)(nil),            // 4: openim.conf.Security
	(*Storage)(nil),             // 5: openim.conf.Storage
	(*durationpb.Duration)(nil), // 6: google.protobuf.Duration
}
var file_openim_proto_depIdxs = []int32{
	1, // 0: openim.conf.OpenIM.server:type_name -> openim.conf.Server
	2, // 1: openim.conf.OpenIM.client:type_name -> openim.conf.Client
	3, // 2: openim.conf.OpenIM.message:type_name -> openim.conf.Message
	4, // 3: openim.conf.OpenIM.security:type_name -> openim.conf.Security
	5, // 4: openim.conf.OpenIM.storage:type_name -> openim.conf.Storage
	6, // 5: openim.conf.Client.timeout:type_name -> google.protobuf.Duration
	6, // 6: openim.conf.Client.heartbeat_interval:type_name -> google.protobuf.Duration
	6, // 7: openim.conf.Security.jwt_expire:type_name -> google.protobuf.Duration
	6, // 8: openim.conf.Storage.timeout:type_name -> google.protobuf.Duration
	9, // [9:9] is the sub-list for method output_type
	9, // [9:9] is the sub-list for method input_type
	9, // [9:9] is the sub-list for extension type_name
	9, // [9:9] is the sub-list for extension extendee
	0, // [0:9] is the sub-list for field type_name
}

func init() { file_openim_proto_init() }
func file_openim_proto_init() {
	if File_openim_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_openim_proto_rawDesc), len(file_openim_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_openim_proto_goTypes,
		DependencyIndexes: file_openim_proto_depIdxs,
		MessageInfos:      file_openim_proto_msgTypes,
	}.Build()
	File_openim_proto = out.File
	file_openim_proto_goTypes = nil
	file_openim_proto_depIdxs = nil
}
